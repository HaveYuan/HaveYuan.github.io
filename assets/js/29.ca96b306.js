(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{533:function(v,_,e){"use strict";e.r(_);var t=e(4),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"什么是http缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是http缓存"}},[v._v("#")]),v._v(" 什么是http缓存")]),v._v(" "),e("p",[v._v("当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。")]),v._v(" "),e("p",[v._v("http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在 "),e("code",[v._v("respone header")]),v._v(" 头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接 "),e("code",[v._v("200")]),v._v("，否则就把请求参数加到 "),e("code",[v._v("request header")]),v._v(" 头中传给服务器，看是否命中协商缓存，命中则返回 "),e("code",[v._v("304")]),v._v("，否则服务器会返回新的资源。")]),v._v(" "),e("h2",{attrs:{id:"缓存的作用优点和缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存的作用优点和缺点"}},[v._v("#")]),v._v(" 缓存的作用优点和缺点")]),v._v(" "),e("h3",{attrs:{id:"优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),e("ul",[e("li",[v._v("减少了不必要的数据传输，节省带宽")]),v._v(" "),e("li",[v._v("减少服务器的负担，提升网站性能")]),v._v(" "),e("li",[v._v("加快了客户端加载网页的速度")])]),v._v(" "),e("h3",{attrs:{id:"缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),e("ul",[e("li",[v._v("如果服务器资源有更新的话客户端不及时更新会造成信息不一致，影响用户体验")])]),v._v(" "),e("h2",{attrs:{id:"缓存的分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存的分类"}},[v._v("#")]),v._v(" 缓存的分类")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/haveyuan/blog_img/blog/http_cache/1.png",alt:"图片"}})]),v._v(" "),e("h3",{attrs:{id:"强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[v._v("#")]),v._v(" 强缓存")]),v._v(" "),e("p",[v._v("强缓存会强制使用浏览器的缓存，它不会向服务器发起请求。强制缓存生效时，http状态码为200。设置强缓存时，可以在服务器返回的 "),e("code",[v._v("header")]),v._v(" 请求头中设置以下字段：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("Expires\n缓存过期时间，是一个具体的时间，表示在这个时间之前缓存都是有效的")])]),v._v(" "),e("li",[e("p",[v._v("Cache-Control\n跟 "),e("code",[v._v("expires")]),v._v(" 类似，也是用来设置缓存有效期，不过它的配置相对较多，如果跟 "),e("code",[v._v("Expires")]),v._v(" 同时开启的话 "),e("code",[v._v("Cache-Control")]),v._v(" 优先级更高，它有以下几个字段：")]),v._v(" "),e("ol",[e("li",[e("p",[e("code",[v._v("max-age")]),v._v(": 指定一个时间长度，在这个时间段内缓存是有效的，单位是s（秒）。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("s-maxage")]),v._v(": 同 "),e("code",[v._v("max-age")]),v._v("，覆盖 "),e("code",[v._v("max-age")]),v._v("、"),e("code",[v._v("Expires")]),v._v("，但仅适用于共享缓存，在私有缓存中被忽略。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("public")]),v._v(": 表明响应可以被任何对象（发送请求的客户端、代理服务器等等）缓存。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("private")]),v._v(": 表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("no-cache")]),v._v(": 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证器的请求到服务器。设置这个的话会跳过强缓存，走协商缓存。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("no-store")]),v._v(": 禁止缓存，每次请求都要向服务器重新获取数据。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("immutable")]),v._v(": 设置这个字段在缓存有效期内用户即使刷新页面（非强制刷新）也不会向服务器发起请求。")])])])])]),v._v(" "),e("h3",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[v._v("#")]),v._v(" 协商缓存")]),v._v(" "),e("p",[v._v("强缓存主要都是在客户端进行判断，如果用户使用 "),e("code",[v._v("ctrl+f5")]),v._v(" 强制刷新的话强缓存会失效，这时候会触发协商缓存，或者服务器返回的响应头中没有 "),e("code",[v._v("Cache-Control")]),v._v(" 和 "),e("code",[v._v("Expires")]),v._v(" 或者 "),e("code",[v._v("Cache-Control")]),v._v("和 "),e("code",[v._v("Expires")]),v._v(" 过期或者它的属性设置为 "),e("code",[v._v("no-cache")]),v._v(" 时也会触发协商缓存。")]),v._v(" "),e("p",[v._v("协商缓存是指服务器返回资源时会在请求头加上一个标识，客户端再次请求服务器时会把这个标识也返回给服务器，服务器通过判断对比标识是否一致来确定是否需要使用缓存，如果命中缓存的话会返回 "),e("code",[v._v("304")]),v._v(" 状态码，告诉浏览器使用缓存，否则返回 "),e("code",[v._v("200")]),v._v("，并且返回最新的资源跟新的标识。")]),v._v(" "),e("p",[v._v("协商缓存主要会用到以下几字段：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("ETag/If-None-Match\n表示每个文件的标识，每次有改动就会重新生成一个，"),e("code",[v._v("ETag")]),v._v(" 返回的是一个 "),e("code",[v._v("hash")]),v._v(" 值，当浏览器第二次发起请求时，会在请求头中带上与 "),e("code",[v._v("ETag")]),v._v(" 对应的 "),e("code",[v._v("If-Not-Match")]),v._v("，其值就是响应头中返回的 "),e("code",[v._v("ETag")]),v._v(" 的值")])]),v._v(" "),e("li",[e("p",[v._v("Last-Modify/If-Modify-Since\n这两个都表示资源最后的修改时间，浏览器第一次请求一个资源的时候，服务器返回的 "),e("code",[v._v("header")]),v._v(" 中会加上 "),e("code",[v._v("Last-Modify")]),v._v("，浏览器再次请求服务器时，请求头中会包含 "),e("code",[v._v("If-Modify-Since")]),v._v("，值为缓存之前返回的 "),e("code",[v._v("Last-Modify")]),v._v("。")])])]),v._v(" "),e("p",[v._v("由于 "),e("code",[v._v("Last-Modify/If-Modify-Since")]),v._v(" 的时间精度是秒级的，如果资源在1秒内修改了多次的话会导致判断不准确，所以才需要 "),e("code",[v._v("ETag/If-None-Match")]),v._v("，它的优先级更高，能够让服务器更加准确的判断是否需要缓存。")]),v._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),e("p",[e("code",[v._v("http")]),v._v(" 缓存主要分为强缓存和协商缓存，当强缓存生效时不会向服务器发起请求，如果缓存时间过期或者用户强制刷新的话则会跳过强缓存进入协商缓存，协商缓存会跟服务器进行比对从而判断是否要使用缓存。")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/haveyuan/blog_img/blog/http_cache/2.png",alt:"图片"}})]),v._v(" "),e("cheers"),v._v(" "),e("pay")],1)}),[],!1,null,null,null);_.default=a.exports}}]);